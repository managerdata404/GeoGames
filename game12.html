<!DOCTYPE html>
<html>
<head>
    <title>Physics-Based Particle Simulator</title>
    <style>
        body { margin: 0; }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }
        .control-group {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 120px;
        }
        #stats {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <label for="temperature">Temperature (K):</label>
            <input type="range" id="temperature" min="100" max="1000" value="300">
            <span id="tempValue">300</span>
        </div>
        <div class="control-group">
            <label for="gravity">Gravity (m/s²):</label>
            <input type="range" id="gravity" min="0" max="20" value="9.8" step="0.1">
            <span id="gravValue">9.8</span>
        </div>
        <div class="control-group">
            <label for="pressure">Volume (m³):</label>
            <input type="range" id="pressure" min="1" max="100" value="50">
            <span id="pressValue">50</span>
        </div>
    </div>
    <div id="stats">
        <div>Average KE: <span id="avgKE">0</span> J</div>
        <div>RMS Velocity: <span id="rmsVel">0</span> m/s</div>
        <div>Pressure: <span id="pressureVal">0</span> Pa</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Physical constants
        const kB = 1.380649e-23;  // Boltzmann constant
        const PARTICLE_MASS = 6.6335209e-26;  // Mass of Argon atom in kg
        const PARTICLE_RADIUS = 0.1;  // Visual radius in simulation units
        const TIME_STEP = 0.001;  // Simulation time step in seconds
        const SCALE_FACTOR = 1e-9; // Scale factor for visualization (1nm = 1 unit)

        // Initialize Three.js scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create container box
        const boxGeometry = new THREE.BoxGeometry(10, 10, 10);
        const boxMaterial = new THREE.MeshBasicMaterial({
            color: 0x808080,
            wireframe: true
        });
        const box = new THREE.Mesh(boxGeometry, boxMaterial);
        scene.add(box);

        // Particle system
        const NUM_PARTICLES = 100;
        const particles = [];
        const particleGeometry = new THREE.SphereGeometry(PARTICLE_RADIUS, 8, 8);

        class Particle {
            constructor() {
                // Create particle with random color based on velocity
                this.material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                this.mesh = new THREE.Mesh(particleGeometry, this.material);

                // Initialize with Maxwell-Boltzmann distribution
                this.velocity = this.generateMaxwellBoltzmannVelocity(300);

                // Random position within box
                this.mesh.position.set(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8
                );

                scene.add(this.mesh);
            }

            generateMaxwellBoltzmannVelocity(temperature) {
                // Generate velocity components using Maxwell-Boltzmann distribution
                const scale = Math.sqrt(kB * temperature / PARTICLE_MASS);

                // Box-Muller transform for Gaussian distribution
                const generateGaussian = () => {
                    const u1 = Math.random();
                    const u2 = Math.random();
                    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                };

                return new THREE.Vector3(
                    generateGaussian() * scale,
                    generateGaussian() * scale,
                    generateGaussian() * scale
                ).multiplyScalar(1e-10); // Scale for visualization
            }

            updateVelocityColor() {
                const speed = this.velocity.length();
                const maxSpeed = 5e-10;
                const hue = Math.min(speed / maxSpeed, 1) * 0.6; // Blue to red
                this.material.color.setHSL(hue, 1, 0.5);
            }

            update(temperature, gravity, volume) {
                // Apply gravity
                this.velocity.y -= gravity * TIME_STEP * 1e-10;

                // Update position
                this.mesh.position.add(this.velocity.clone().multiplyScalar(TIME_STEP));

                // Handle collisions with walls (elastic collisions)
                const pos = this.mesh.position;
                const boxSize = 4 + (volume - 50) / 25; // Box size varies with volume

                if (Math.abs(pos.x) > boxSize) {
                    pos.x = Math.sign(pos.x) * boxSize;
                    this.velocity.x *= -1;
                }
                if (Math.abs(pos.y) > boxSize) {
                    pos.y = Math.sign(pos.y) * boxSize;
                    this.velocity.y *= -1;
                }
                if (Math.abs(pos.z) > boxSize) {
                    pos.z = Math.sign(pos.z) * boxSize;
                    this.velocity.z *= -1;
                }

                // Occasionally adjust velocity based on temperature (thermal equilibrium)
                if (Math.random() < 0.01) {
                    const currentSpeed = this.velocity.length();
                    const targetVelocity = this.generateMaxwellBoltzmannVelocity(temperature);
                    this.velocity.lerp(targetVelocity, 0.1);
                }

                this.updateVelocityColor();
            }
        }

        // Create particles
        for (let i = 0; i < NUM_PARTICLES; i++) {
            particles.push(new Particle());
        }

        // Camera position
        camera.position.z = 15;

        // Controls
        const tempSlider = document.getElementById('temperature');
        const gravSlider = document.getElementById('gravity');
        const pressSlider = document.getElementById('pressure');
        const tempValue = document.getElementById('tempValue');
        const gravValue = document.getElementById('gravValue');
        const pressValue = document.getElementById('pressValue');
        const avgKEDisplay = document.getElementById('avgKE');
        const rmsVelDisplay = document.getElementById('rmsVel');
        const pressureDisplay = document.getElementById('pressureVal');

        tempSlider.addEventListener('input', () => {
            tempValue.textContent = tempSlider.value;
        });
        gravSlider.addEventListener('input', () => {
            gravValue.textContent = gravSlider.value;
        });
        pressSlider.addEventListener('input', () => {
            pressValue.textContent = pressSlider.value;
        });

        // Calculate system statistics
        function updateStats() {
            // Calculate average kinetic energy
            const avgKE = particles.reduce((sum, p) => {
                const v = p.velocity.length();
                return sum + 0.5 * PARTICLE_MASS * v * v;
            }, 0) / particles.length;

            // Calculate RMS velocity
            const rmsVel = Math.sqrt(particles.reduce((sum, p) => {
                const v = p.velocity.length();
                return sum + v * v;
            }, 0) / particles.length);

            // Calculate pressure (simplified using ideal gas law PV = NkT)
            const volume = Math.pow(8 + (parseFloat(pressSlider.value) - 50) / 25, 3);
            const temperature = parseFloat(tempSlider.value);
            const pressure = NUM_PARTICLES * kB * temperature / volume;

            avgKEDisplay.textContent = avgKE.toExponential(3);
            rmsVelDisplay.textContent = rmsVel.toExponential(3);
            pressureDisplay.textContent = pressure.toExponential(3);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const temperature = parseFloat(tempSlider.value);
            const gravity = parseFloat(gravSlider.value);
            const volume = parseFloat(pressSlider.value);

            // Update particle positions
            particles.forEach(particle => {
                particle.update(temperature, gravity, volume);
            });

            // Rotate box slightly
            box.rotation.x += 0.001;
            box.rotation.y += 0.001;

            // Update statistics
            updateStats();

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>