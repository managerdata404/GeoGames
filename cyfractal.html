<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cymatics Fractal with RGB Blending</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-family: Arial, sans-serif;
    }
    #controls button, #controls select {
      margin: 5px;
      padding: 10px 15px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <select id="fractalSelector">
      <option value="julia">Julia Set</option>
      <option value="mandelbrot">Mandelbrot Set</option>
      <option value="sierpinski">Sierpinski Triangle</option>
    </select>
    <button id="startButton">Start</button>
    <button id="resetButton">Reset</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const particles = [];
    const gridSize = 30; // Grid size (total particles: gridSize * gridSize)
    const boundarySize = Math.min(canvas.width, canvas.height) * 0.8; // Square boundary size
    const boundaryX = (canvas.width - boundarySize) / 2; // Left edge of the boundary
    const boundaryY = (canvas.height - boundarySize) / 2; // Top edge of the boundary
    const colors = ["red", "green", "blue"];
    let isRunning = false;
    let fractalType = "julia";

    function generateParticles() {
      particles.length = 0;
      const spacingX = boundarySize / gridSize;
      const spacingY = boundarySize / gridSize;

      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const color = colors[(i + j) % 3];
          particles.push({
            x: boundaryX + j * spacingX + spacingX / 2,
            y: boundaryY + i * spacingY + spacingY / 2,
            vx: 0,
            vy: 0,
            energy: 1,
            color: color,
            originalColor: color, // Track the original color
          });
        }
      }
    }

    function blendColors(p1, p2) {
      const toRGB = (color) => {
        if (color === "red") return [255, 0, 0];
        if (color === "green") return [0, 255, 0];
        if (color === "blue") return [0, 0, 255];
        return [0, 0, 0];
      };

      const [r1, g1, b1] = toRGB(p1.color);
      const [r2, g2, b2] = toRGB(p2.color);

      const blendedR = Math.min(r1 + r2, 255);
      const blendedG = Math.min(g1 + g2, 255);
      const blendedB = Math.min(b1 + b2, 255);

      if (blendedR === 255 && blendedG === 255 && blendedB === 255) {
        return "white"; // Full overlap results in white
      }

      return `rgb(${blendedR}, ${blendedG}, ${blendedB})`;
    }

    function updateParticles(time) {
      for (let particle of particles) {
        const dx = particle.x - (boundaryX + boundarySize / 2);
        const dy = particle.y - (boundaryY + boundarySize / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);

        let angle, scale;

        if (fractalType === "julia") {
          angle = Math.atan2(dy, dx) + Math.sin(time * 0.001);
          scale = Math.cos(distance * 0.01 + time * 0.001) * 2;
        } else if (fractalType === "mandelbrot") {
          angle = Math.atan2(dy, dx) + Math.sin(distance * 0.01 - time * 0.001);
          scale = Math.sin(distance * 0.02 + time * 0.001) * 2;
        } else if (fractalType === "sierpinski") {
          angle = Math.atan2(dy, dx) * (Math.PI / 3);
          scale = 1 + Math.cos(distance * 0.02 - time * 0.001) * 0.5;
        }

        particle.vx += Math.cos(angle) * scale * particle.energy;
        particle.vy += Math.sin(angle) * scale * particle.energy;

        particle.energy *= 0.99;

        particle.x += particle.vx;
        particle.y += particle.vy;

        if (particle.x <= boundaryX || particle.x >= boundaryX + boundarySize) {
          particle.vx *= -1;
          particle.x = Math.max(boundaryX, Math.min(particle.x, boundaryX + boundarySize));
        }
        if (particle.y <= boundaryY || particle.y >= boundaryY + boundarySize) {
          particle.vy *= -1;
          particle.y = Math.max(boundaryY, Math.min(particle.y, boundaryY + boundarySize));
        }

        particle.vx *= 0.98;
        particle.vy *= 0.98;
      }

      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const p1 = particles[i];
          const p2 = particles[j];

          if (Math.abs(p1.x - p2.x) < 5 && Math.abs(p1.y - p2.y) < 5) {
            p1.color = blendColors(p1, p2);
            p2.color = p1.color;
          } else {
            p1.color = p1.originalColor;
            p2.color = p2.originalColor;
          }
        }
      }
    }

    function drawParticles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.strokeRect(boundaryX, boundaryY, boundarySize, boundarySize);

      for (let particle of particles) {
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function animate(time) {
      if (!isRunning) return;

      updateParticles(time);
      drawParticles();
      requestAnimationFrame(animate);
    }

    document.getElementById("startButton").addEventListener("click", () => {
      if (!isRunning) {
        isRunning = true;
        animate(performance.now());
      }
    });

    document.getElementById("resetButton").addEventListener("click", () => {
      isRunning = false;
      generateParticles();
      drawParticles();
    });

    document.getElementById("fractalSelector").addEventListener("change", (event) => {
      fractalType = event.target.value;
    });

    generateParticles();
    drawParticles();
  </script>
</body>
</html>