<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cymatics Fractal Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-family: Arial, sans-serif;
    }
    #controls button, #controls select {
      margin: 5px;
      padding: 10px 15px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <select id="fractalSelector">
      <option value="julia">Julia Set</option>
      <option value="mandelbrot">Mandelbrot Set</option>
      <option value="sierpinski">Sierpinski Triangle</option>
    </select>
    <button id="startButton">Start</button>
    <button id="resetButton">Reset</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const particles = [];
    const gridSize = 30; // Grid size (total particles: gridSize * gridSize)
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const colors = ["red", "green", "blue"];
    let isRunning = false;
    let fractalType = "julia";

    // Initialize particles
    function generateParticles() {
      particles.length = 0;
      const spacingX = canvas.width / gridSize;
      const spacingY = canvas.height / gridSize;

      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const color = colors[(i + j) % 3];
          particles.push({
            x: j * spacingX + spacingX / 2,
            y: i * spacingY + spacingY / 2,
            vx: 0,
            vy: 0,
            energy: 1,
            color: color,
          });
        }
      }
    }

    // RGB blending function
    function blendColors(color1, color2) {
      const toRGB = (color) => {
        if (color === "red") return [255, 0, 0];
        if (color === "green") return [0, 255, 0];
        if (color === "blue") return [0, 0, 255];
        return [0, 0, 0];
      };

      const [r1, g1, b1] = toRGB(color1);
      const [r2, g2, b2] = toRGB(color2);
      return `rgb(${Math.min(r1 + r2, 255)}, ${Math.min(g1 + g2, 255)}, ${Math.min(b1 + b2, 255)})`;
    }

    // Update particles based on fractal algorithm
    function updateParticles(time) {
      for (let particle of particles) {
        const dx = particle.x - centerX;
        const dy = particle.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        let angle, scale;

        // Apply fractal-specific transformations
        if (fractalType === "julia") {
          angle = Math.atan2(dy, dx) + Math.sin(time * 0.001);
          scale = Math.cos(distance * 0.01 + time * 0.001) * 2;
        } else if (fractalType === "mandelbrot") {
          angle = Math.atan2(dy, dx) + Math.sin(distance * 0.01 - time * 0.001);
          scale = Math.sin(distance * 0.02 + time * 0.001) * 2;
        } else if (fractalType === "sierpinski") {
          angle = Math.atan2(dy, dx) * (Math.PI / 3);
          scale = 1 + Math.cos(distance * 0.02 - time * 0.001) * 0.5;
        }

        // Update velocities based on fractal pattern
        particle.vx += Math.cos(angle) * scale * particle.energy;
        particle.vy += Math.sin(angle) * scale * particle.energy;

        // Energy dissipation
        particle.energy *= 0.99;

        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Slow down particles
        particle.vx *= 0.98;
        particle.vy *= 0.98;
      }

      // Apply RGB blending when particles overlap
      for (let i = 0; i < particles.length; i++) {
        for (let j = i + 1; j < particles.length; j++) {
          const p1 = particles[i];
          const p2 = particles[j];

          if (
            Math.abs(p1.x - p2.x) < 5 &&
            Math.abs(p1.y - p2.y) < 5
          ) {
            p1.color = blendColors(p1.color, p2.color);
          }
        }
      }
    }

    // Draw particles
    function drawParticles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let particle of particles) {
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Animation loop
    function animate(time) {
      if (!isRunning) return;

      updateParticles(time);
      drawParticles();

      requestAnimationFrame(animate);
    }

    // Event listeners
    document.getElementById("startButton").addEventListener("click", () => {
      if (!isRunning) {
        isRunning = true;
        animate(performance.now());
      }
    });

    document.getElementById("resetButton").addEventListener("click", () => {
      isRunning = false;
      generateParticles();
      drawParticles();
    });

    document.getElementById("fractalSelector").addEventListener("change", (event) => {
      fractalType = event.target.value;
    });

    // Initialize particles
    generateParticles();
    drawParticles();
  </script>
</body>
</html>