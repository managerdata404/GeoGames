<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cymatics and Fractal Simulation</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      color: white;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 8px;
    }
    #controls select, #controls button {
      margin-bottom: 10px;
      display: block;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="fractalType">Select Fractal Algorithm:</label>
    <select id="fractalType">
      <option value="julia">Julia Set</option>
      <option value="mandelbrot">Mandelbrot Set</option>
      <option value="ifs">IFS (Barnsley Fern)</option>
      <option value="random">Random (Perlin Noise)</option>
      <option value="lsystem">L-System (Dragon Curve)</option>
    </select>
    <button id="start">Start</button>
    <button id="reset">Reset</button>
  </div>
  <canvas></canvas>
  <script>
    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const PARTICLE_COUNT = 900; // 300 Red, 300 Green, 300 Blue
    const BOUNDARY_SIZE = Math.min(canvas.width, canvas.height) * 0.8;
    const CENTER_X = canvas.width / 2;
    const CENTER_Y = canvas.height / 2;
    const PARTICLE_RADIUS = 2;
    const DECAY_RATE = 0.005; // Energy reduction rate

    let particles = [];
    let fractalType = 'julia';
    let running = false;

    // Initialize particles in rows (300 red, 300 green, 300 blue)
    function initParticles() {
      particles = [];
      const rows = Math.ceil(Math.sqrt(PARTICLE_COUNT));
      const startX = CENTER_X - BOUNDARY_SIZE / 2;
      const startY = CENTER_Y - BOUNDARY_SIZE / 2;
      const gap = BOUNDARY_SIZE / rows;

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const row = Math.floor(i / rows);
        const col = i % rows;
        const x = startX + col * gap;
        const y = startY + row * gap;
        const color = i < 300 ? 'red' : i < 600 ? 'green' : 'blue';

        particles.push({ x, y, vx: 0, vy: 0, energy: 1, color });
      }
    }

    // Draw the boundary
    function drawBoundary() {
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.strokeRect(
        CENTER_X - BOUNDARY_SIZE / 2,
        CENTER_Y - BOUNDARY_SIZE / 2,
        BOUNDARY_SIZE,
        BOUNDARY_SIZE
      );
    }

    // Draw particles
    function drawParticles() {
      particles.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, PARTICLE_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
      });
    }

    // Update particles' positions and energies
    function updateParticles() {
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;

        // Apply boundary bounce
        if (p.x - PARTICLE_RADIUS < CENTER_X - BOUNDARY_SIZE / 2 || p.x + PARTICLE_RADIUS > CENTER_X + BOUNDARY_SIZE / 2) {
          p.vx *= -1;
        }
        if (p.y - PARTICLE_RADIUS < CENTER_Y - BOUNDARY_SIZE / 2 || p.y + PARTICLE_RADIUS > CENTER_Y + BOUNDARY_SIZE / 2) {
          p.vy *= -1;
        }

        // Apply energy decay
        p.energy -= DECAY_RATE;
        if (p.energy < 0) p.energy = 0;

        // Blending RGB
        const overlappingParticles = particles.filter(other => {
          return other !== p && Math.hypot(other.x - p.x, other.y - p.y) < PARTICLE_RADIUS;
        });

        if (overlappingParticles.length > 0) {
          const red = overlappingParticles.filter(o => o.color === 'red').length > 0 ? 255 : 0;
          const green = overlappingParticles.filter(o => o.color === 'green').length > 0 ? 255 : 0;
          const blue = overlappingParticles.filter(o => o.color === 'blue').length > 0 ? 255 : 0;
          p.color = `rgb(${red}, ${green}, ${blue})`;
        }
      });
    }

    // Apply fractal algorithm
    function applyFractal() {
      particles.forEach(p => {
        if (fractalType === 'julia') {
          const zx = p.x - CENTER_X;
          const zy = p.y - CENTER_Y;
          const nx = zx * zx - zy * zy + 0.355;
          const ny = 2 * zx * zy + 0.355;
          p.vx += nx * 0.01;
          p.vy += ny * 0.01;
        }
        // Add other fractal algorithms here...
      });
    }

    // Main animation loop
    function animate() {
      if (!running) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBoundary();
      updateParticles();
      applyFractal();
      drawParticles();
      requestAnimationFrame(animate);
    }

    // Start simulation
    document.getElementById('start').addEventListener('click', () => {
      running = true;
      animate();
    });

    // Reset simulation
    document.getElementById('reset').addEventListener('click', () => {
      running = false;
      initParticles();
      drawBoundary();
      drawParticles();
    });

    // Fractal type selection
    document.getElementById('fractalType').addEventListener('change', e => {
      fractalType = e.target.value;
    });

    // Initialize
    initParticles();
    drawBoundary();
    drawParticles();
  </script>
</body>
</html>